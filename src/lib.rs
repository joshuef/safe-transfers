// Copyright 2020 MaidSafe.net limited.
//
// This SAFE Network Software is licensed to you under The General Public License (GPL), version 3.
// Unless required by applicable law or agreed to in writing, the SAFE Network Software distributed
// under the GPL Licence is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied. Please review the Licences for the specific language governing
// permissions and limitations relating to use of the SAFE Network Software.

//! Implementation of Transfers in the SAFE Network.

#![doc(
    html_logo_url = "https://raw.githubusercontent.com/maidsafe/QA/master/Images/maidsafe_logo.png",
    html_favicon_url = "https://maidsafe.net/img/favicon.ico",
    test(attr(forbid(warnings)))
)]
// For explanation of lint checks, run `rustc -W help`.
#![forbid(unsafe_code)]
#![warn(
    missing_docs,
    trivial_casts,
    trivial_numeric_casts,
    unused_extern_crates,
    unused_import_braces,
    unused_qualifications,
    unused_results
)]

mod account;
mod actor;
mod replica;

pub use self::{
    account::Account, actor::Actor as TransferActor, replica::Replica as TransferReplica,
    ReplicaEvent as TransferReplicaEvent,
};

use crdts::Dot;
use safe_nd::{Money, PublicKey, Signature};
use serde::{Deserialize, Serialize};
use threshold_crypto::PublicKeySet;

/// ACtor / Replica / Group id
pub type AccountId = PublicKey;

/// Transfer ID.
pub type TransferId = Dot<AccountId>;

/// A transfer of money between two keys.
#[derive(Clone, Hash, Eq, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
pub struct Transfer {
    /// Transfer ID, containing source key.
    pub id: TransferId,
    /// The destination to transfer to.
    pub to: AccountId,
    /// The amount to transfer.
    pub amount: Money,
}

/// The aggregated Replica signatures of the Actor debit cmd.
#[derive(Clone, Hash, Eq, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
pub struct DebitAgreementProof {
    /// The cmd generated by sender Actor.
    pub transfer_cmd: ValidateTransfer,
    /// Quorum of Replica sigs over the transfer cmd.
    pub sender_replicas_sig: Signature,
}

/// The recipient's aggregated Replica signatures of the received DebitAgreementProof.
#[derive(Clone, Hash, Eq, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
pub struct CreditAgreementProof {
    /// The sender's aggregated Replica signatures of the sender debit.
    pub debit_proof: DebitAgreementProof,
    /// A recipient's Replicas' aggregated sig over the debit_proof.
    pub receiver_replica_sig: Signature,
}

/// A signature share, with its index in the combined collection.
#[derive(Clone, Hash, Eq, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
pub struct SignatureShare {
    /// Index in the combined collection.
    pub index: usize,
    /// Replica signature over the transfer cmd.
    pub share: threshold_crypto::SignatureShare,
}

// ------------------------------------------------------------
//                      Replica
// ------------------------------------------------------------

/// Events raised by the Replica.
#[derive(Clone, Hash, Eq, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
pub enum ReplicaEvent {
    /// The event raised when
    /// ValidateTransfer cmd has been successful.
    TransferValidated(TransferValidated),
    /// The event raised when
    /// RegisterTransfer cmd has been successful.
    TransferRegistered(TransferRegistered),
    /// The event raised when
    /// PropagateTransfer cmd has been successful.
    TransferPropagated(TransferPropagated),
    /// The event raised when
    /// peers changed so that we have a new PublicKeySet.
    PeersChanged(PeersChanged),
    /// The event raised when
    /// we learn of a new group PK set.
    KnownGroupAdded(KnownGroupAdded),
}

/// The debiting Replica event raised when
/// ValidateTransfer cmd has been successful.
#[derive(Clone, Hash, Eq, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
pub struct TransferValidated {
    /// The cmd generated by Actor.
    pub transfer_cmd: ValidateTransfer,
    /// Replica signature over the transfer cmd.
    pub replica_signature: SignatureShare,
    /// The PK Set of the Replicas
    pub replicas: PublicKeySet,
    // NB: I'm a bit ambivalent to this implicit communication of public key change.
    // I generally prefer an explicit cmd + event for such a significant part of the logic.
    // Including it here minimizes msg types and traffic, and seamlessly - apparently -
    // updates Actors on any public key change, which they can accumulate in order to
    // apply the change to local state.
    // But it inflicts on, and complicates the logic for validating a transfer..
    // Cost / benefit to be discussed..
}

/// The debiting Replica event raised when
/// RegisterTransfer cmd has been successful.
#[derive(Clone, Hash, Eq, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
pub struct TransferRegistered {
    /// The debit proof.
    pub debit_proof: DebitAgreementProof,
}

/// The crediting Replica event raised when
/// PropagateTransfer cmd has been successful.
#[derive(Clone, Hash, Eq, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
pub struct TransferPropagated {
    /// The debiting Replicas' proof.
    pub debit_proof: DebitAgreementProof,
    /// The crediting Replica signature.
    pub replica_sig: SignatureShare,
}

/// The Replica event raised when
/// peers changed so that we have a new PublicKeySet.
#[derive(Clone, Hash, Eq, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
pub struct PeersChanged {
    /// Our new PublicKeySet.
    pub peers: PublicKeySet,
}

/// The Replica event raised when
/// we learn of a new group PK set.
#[derive(Clone, Hash, Eq, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
pub struct KnownGroupAdded {
    /// The PublicKeySet of the group.
    pub group: PublicKeySet,
}

// ------------------------------------------------------------
//                      Actor
// ------------------------------------------------------------

/// An Actor cmd.
#[derive(Clone, Hash, Eq, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
pub struct ValidateTransfer {
    /// The transfer.
    pub transfer: Transfer,
    /// Actor signature over the transfer.
    pub actor_signature: Signature,
}

/// An Actor cmd.
#[derive(Clone, Hash, Eq, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
pub struct RegisterTransfer {
    /// The transfer proof.
    pub proof: DebitAgreementProof,
}

/// Events raised by the Actor.
#[derive(Clone, Hash, Eq, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
pub enum ActorEvent {
    /// Raised when a request to create
    /// a transfer validation cmd for Replicas,
    /// has been successful (valid on local state).
    TransferInitiated(TransferInitiated),
    /// Raised when an Actor receives a Replica transfer validation.
    TransferValidationReceived(TransferValidationReceived),
    /// Raised when the Actor has accumulated a
    /// quorum of validations, and produced a RegisterTransfer cmd
    /// for sending to Replicas.
    TransferRegistrationSent(TransferRegistrationSent),
    /// Raised when the Actor has received
    /// unknown credits on querying Replicas.
    NewCreditsReceived(NewCreditsReceived),
    /// Raised when the Actor has received
    /// unknown debits on querying Replicas.
    NewDebitsReceived(NewDebitsReceived),
}

/// This event is raised by the Actor after having
/// successfully created a transfer cmd to send to the
/// Replicas for validation.
#[derive(Clone, Hash, Eq, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
pub struct TransferInitiated {
    cmd: ValidateTransfer,
}

/// Raised when a Replica responds with
/// a successful validation of a transfer.
#[derive(Clone, Hash, Eq, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
pub struct TransferValidationReceived {
    /// The event raised by a Replica.
    validation: TransferValidated,
    /// Added when quorum of validations
    /// have been received from Replicas.
    proof: Option<DebitAgreementProof>,
}

/// Raised when the Actor has accumulated a
/// quorum of validations, and produced a RegisterTransfer cmd
/// for sending to Replicas.
#[derive(Clone, Hash, Eq, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
pub struct TransferRegistrationSent {
    cmd: RegisterTransfer,
}

/// The recipient's single Replica signature of the received DebitAgreementProof.
#[derive(Clone, Hash, Eq, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
pub struct SignedCredit {
    /// The sender's aggregated Replica signatures of the sender debit.
    pub debit_proof: DebitAgreementProof,
    /// A single recipient's Replica sig over the debit_proof.
    /// The recipient Actor need to aggregate this.
    pub receiver_replica_sig: SignatureShare,
}

/// Raised when the Actor has received
/// credits that its Replicas were holding upon
/// the propagation of them from a remote group of Replicas.
#[derive(Clone, Hash, Eq, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
pub struct NewCreditsReceived {
    /// Credits we don't have locally, validated by a single Replica.
    /// We don't apply them, simply begin accumulate the signatures.
    accumulating_credits: Vec<SignedCredit>,
    /// Credits we have been accumulating,
    /// and where we now got a quorum of Replicas signing them,
    /// thus producing a proof. These can now be applied to the Actor balance.
    accumulated_credit_proofs: Vec<CreditAgreementProof>,
}

/// Raised when an Actor instance has received
/// unknown debits that its Replicas were holding
/// upon the registration of them from another
/// instance of the same Actor.
#[derive(Clone, Hash, Eq, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
pub struct NewDebitsReceived {
    /// The debits we do not have locally.
    debits: Vec<DebitAgreementProof>,
}
